// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                          FICHIER: Cargo.toml                             â•‘
// â•‘  Fichier de configuration du projet Rust                                 â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[package]
name = "logo-rust-bevy"
version = "0.1.0"
edition = "2021"

[dependencies]
bevy = "0.16.1"

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                          FICHIER: src/main.rs                            â•‘
// â•‘  Point d'entrÃ©e de l'application                                         â•‘
// â•‘  RÃ´le : Lancer l'application Bevy configurÃ©e dans lib.rs                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Importe la fonction run() depuis le module library
use logo_rust_bevy::run;

/// Point d'entrÃ©e principal de l'application
/// 
/// Cette fonction est appelÃ©e automatiquement au lancement du programme.
/// Elle dÃ©lÃ¨gue toute la logique Ã  la fonction run() dÃ©finie dans lib.rs
/// pour maintenir une sÃ©paration claire entre le point d'entrÃ©e et la logique.
fn main() {
    // Lancement de l'application Bevy
    run();
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                          FICHIER: src/lib.rs                             â•‘
// â•‘  Module racine de la bibliothÃ¨que                                        â•‘
// â•‘  RÃ´le : DÃ©clarer tous les modules et configurer l'application Bevy      â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

use bevy::prelude::*;

// === DÃ‰CLARATION DES MODULES ===
// Chaque module est dÃ©fini dans un fichier sÃ©parÃ© pour une meilleure organisation

/// Module de configuration - Contient toutes les constantes du projet
pub mod config;

/// Module des matÃ©riaux - GÃ¨re les couleurs et apparences visuelles
pub mod materials;

/// Module de gÃ©omÃ©trie - Fonctions de crÃ©ation de formes et calculs mathÃ©matiques
pub mod geometry;

/// Module des systÃ¨mes - Contient la logique de setup et autres systÃ¨mes Bevy
pub mod systems;

// Import du systÃ¨me de setup pour l'utiliser dans la configuration
use systems::setup::setup_system;

/// Fonction principale qui configure et lance l'application Bevy
/// 
/// Cette fonction crÃ©e une nouvelle application Bevy avec :
/// - Les plugins par dÃ©faut (fenÃªtre, rendu, input, etc.)
/// - Le systÃ¨me de setup qui s'exÃ©cute au dÃ©marrage
/// 
/// L'application tourne en boucle jusqu'Ã  ce que l'utilisateur ferme la fenÃªtre.
pub fn run() {
    App::new()
        // === PLUGINS BEVY ===
        // DefaultPlugins inclut tous les systÃ¨mes essentiels :
        // - WindowPlugin : gestion de la fenÃªtre
        // - RenderPlugin : moteur de rendu
        // - InputPlugin : clavier, souris, gamepad
        // - AssetPlugin : chargement des assets
        // - et bien d'autres...
        .add_plugins(DefaultPlugins)
        
        // === SYSTÃˆMES DE DÃ‰MARRAGE ===
        // Startup : systÃ¨mes exÃ©cutÃ©s une seule fois au lancement
        // Notre systÃ¨me setup_system crÃ©e tous les Ã©lÃ©ments visuels
        .add_systems(Startup, setup_system)
        
        // === LANCEMENT ===
        // DÃ©marre la boucle de jeu (game loop)
        // Cette fonction bloque jusqu'Ã  la fermeture de l'application
        .run();
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        FICHIER: src/config.rs                            â•‘
// â•‘  Configuration globale de l'application                                  â•‘
// â•‘  RÃ´le : Centraliser toutes les constantes pour faciliter les ajustementsâ•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

//! Module de configuration
//! 
//! Ce module centralise toutes les valeurs configurables du projet.
//! Avantages :
//! - Modification facile des paramÃ¨tres sans toucher au code mÃ©tier
//! - Vue d'ensemble des dimensions et quantitÃ©s
//! - Ã‰vite les "magic numbers" dispersÃ©s dans le code

// === CONFIGURATION DU CERCLE PRINCIPAL ===

/// Rayon du cercle principal en pixels
/// 
/// DÃ©termine la taille globale du logo. Toutes les autres
/// dimensions sont calculÃ©es relativement Ã  ce rayon.
/// Valeur recommandÃ©e : 150-300 pour un affichage confortable
pub const CIRCLE_RADIUS: f32 = 200.0;

/// Ã‰paisseur de l'anneau du cercle principal en pixels
/// 
/// DÃ©finit l'Ã©paisseur de la bande colorÃ©e du cercle.
/// Plus la valeur est Ã©levÃ©e, plus l'anneau est Ã©pais.
/// Recommandation : 10-15% du rayon (20-40 px pour rayon 200)
pub const CIRCLE_THICKNESS: f32 = 30.0;

/// Nombre de segments pour le rendu des cercles
/// 
/// Plus le nombre est Ã©levÃ©, plus le cercle est lisse mais
/// plus le calcul est coÃ»teux. Valeurs recommandÃ©es :
/// - 32 : performance (cercle lÃ©gÃ¨rement anguleux)
/// - 64 : Ã©quilibrÃ© (recommandÃ©)
/// - 128 : qualitÃ© maximale (pour zoom ou export)
pub const CIRCLE_SEGMENTS: usize = 64;

// === CONFIGURATION DES TRIANGLES EXTÃ‰RIEURS ===

/// Nombre de triangles extÃ©rieurs disposÃ©s autour du cercle
/// 
/// Ces triangles forment un anneau arc-en-ciel autour du cercle.
/// Valeur actuelle : 36 triangles espacÃ©s de 10Â° (360Â°/36)
/// Modification : doit Ãªtre un diviseur de 360 pour un espacement rÃ©gulier
/// Exemples : 12 (30Â°), 24 (15Â°), 36 (10Â°), 72 (5Â°)
pub const EXTERIOR_TRIANGLES_COUNT: usize = 36;

/// Taille d'un cÃ´tÃ© des triangles extÃ©rieurs en pixels
/// 
/// DÃ©finit la dimension des petits triangles arc-en-ciel.
/// Recommandation : 10-15% du rayon pour un rendu harmonieux
pub const SMALL_TRIANGLE_SIDE: f32 = 25.0;

// === CONFIGURATION DES TRIANGLES INTÃ‰RIEURS ===

/// Nombre de triangles intÃ©rieurs formant un pentagone
/// 
/// Valeur fixe : 5 triangles pour crÃ©er une Ã©toile Ã  5 branches
/// Modification dÃ©conseillÃ©e sauf pour crÃ©er d'autres formes :
/// - 3 : triangle
/// - 4 : carrÃ©
/// - 6 : hexagone
pub const INTERIOR_TRIANGLES_COUNT: usize = 5;

/// Taille d'un cÃ´tÃ© des triangles intÃ©rieurs en pixels
/// 
/// Ces triangles sont plus grands que les extÃ©rieurs.
/// Recommandation : 35-45% du rayon pour remplir l'espace intÃ©rieur
pub const LARGE_TRIANGLE_SIDE: f32 = 80.0;

// === CONFIGURATION DES PETITS CERCLES ===

/// Rayon des petits cercles au centre de chaque triangle intÃ©rieur
/// 
/// Ces cercles marquent le centroÃ¯de de chaque grand triangle.
/// Recommandation : 5-10% du rayon principal
pub const SMALL_CIRCLE_RADIUS: f32 = 15.0;

/// QualitÃ© de rendu des petits cercles
/// 
/// Peut Ãªtre infÃ©rieur Ã  CIRCLE_SEGMENTS car ces cercles sont plus petits.
/// Valeurs recommandÃ©es : 24-48
pub const SMALL_CIRCLE_SEGMENTS: usize = 32;

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                      FICHIER: src/materials.rs                           â•‘
// â•‘  Gestion des couleurs et matÃ©riaux                                       â•‘
// â•‘  RÃ´le : DÃ©finir l'apparence visuelle de tous les Ã©lÃ©ments               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

//! Module de gestion des matÃ©riaux et couleurs
//! 
//! Ce module centralise toutes les dÃ©finitions de couleurs pour :
//! - CohÃ©rence visuelle du projet
//! - Modification facile des palettes de couleurs
//! - RÃ©utilisation des couleurs

use bevy::prelude::*;

/// Retourne le matÃ©riau pour le cercle principal (anneau Ã©pais)
/// 
/// Couleur actuelle : Rouge-orangÃ© (#CC3319 approximatif)
/// Format SRGB : (Rouge: 0.8, Vert: 0.2, Bleu: 0.1)
/// 
/// Pour changer la couleur :
/// - Rouge vif : (1.0, 0.0, 0.0)
/// - Bleu : (0.2, 0.4, 0.8)
/// - Vert : (0.2, 0.8, 0.3)
pub fn get_main_circle_color() -> ColorMaterial {
    ColorMaterial::from(Color::srgb(0.8, 0.2, 0.1))
}

/// GÃ©nÃ¨re une couleur arc-en-ciel basÃ©e sur l'index du triangle
/// 
/// Principe : utilise le systÃ¨me HSL (Teinte, Saturation, LuminositÃ©)
/// - Teinte (H) : varie de 0Â° Ã  360Â° pour parcourir toutes les couleurs
/// - Saturation (S) : 0.8 (80%) pour des couleurs vives mais pas criardes
/// - LuminositÃ© (L) : 0.6 (60%) pour Ã©viter les couleurs trop claires ou trop sombres
/// 
/// # Arguments
/// * `index` - Position du triangle (0 Ã  EXTERIOR_TRIANGLES_COUNT-1)
/// 
/// # Exemples de couleurs gÃ©nÃ©rÃ©es
/// - Index 0 (0Â°) : Rouge
/// - Index 9 (90Â°) : Jaune-vert
/// - Index 18 (180Â°) : Cyan
/// - Index 27 (270Â°) : Violet
pub fn get_rainbow_color(index: usize) -> ColorMaterial {
    // Calcul de l'angle de teinte : chaque triangle dÃ©cale de 10Â°
    let hue_fraction = (index as f32 * 10.0) / 360.0;
    
    // Conversion en angle complet (0-360Â°)
    let hue_degrees = hue_fraction * 360.0;
    
    // CrÃ©ation de la couleur HSL
    let color = Color::hsl(
        hue_degrees,  // Teinte : 0-360Â°
        0.8,          // Saturation : 80% (couleurs vives)
        0.6           // LuminositÃ© : 60% (ni trop clair ni trop foncÃ©)
    );
    
    ColorMaterial::from(color)
}

/// Retourne la couleur d'un triangle intÃ©rieur selon son index
/// 
/// Palette de 5 couleurs distinctes qui se rÃ©pÃ¨tent si nÃ©cessaire.
/// Chaque couleur est choisie pour Ãªtre bien distincte des autres.
/// 
/// # Palette actuelle
/// 0. Bleu azur : pour le calme et la confiance
/// 1. Orange : pour l'Ã©nergie et la crÃ©ativitÃ©
/// 2. Vert Ã©meraude : pour la nature et l'harmonie
/// 3. Rose fuchsia : pour l'originalitÃ©
/// 4. Violet : pour la sophistication
/// 
/// # Arguments
/// * `index` - Position du triangle (0 Ã  INTERIOR_TRIANGLES_COUNT-1)
pub fn get_interior_triangle_color(index: usize) -> ColorMaterial {
    // DÃ©finition de la palette de couleurs
    let colors = [
        Color::srgb(0.2, 0.6, 0.9), // Bleu azur
        Color::srgb(0.9, 0.6, 0.2), // Orange
        Color::srgb(0.2, 0.9, 0.6), // Vert Ã©meraude
        Color::srgb(0.9, 0.2, 0.6), // Rose fuchsia
        Color::srgb(0.6, 0.2, 0.9), // Violet
    ];
    
    // Utilisation du modulo pour gÃ©rer les index supÃ©rieurs Ã  5
    // Exemple : index 7 â†’ 7 % 5 = 2 â†’ couleur verte
    ColorMaterial::from(colors[index % colors.len()])
}

/// Retourne le matÃ©riau pour les petits cercles centraux
/// 
/// Couleur : Blanc semi-transparent (opacitÃ© 70%)
/// L'alpha (transparence) permet de voir les triangles en dessous
/// tout en marquant visuellement le centre.
/// 
/// Format SRGBA : (Rouge: 1.0, Vert: 1.0, Bleu: 1.0, Alpha: 0.7)
/// Pour ajuster la transparence, modifier la derniÃ¨re valeur :
/// - 0.5 : plus transparent
/// - 0.9 : presque opaque
pub fn get_small_circle_color() -> ColorMaterial {
    ColorMaterial::from(Color::srgba(1.0, 1.0, 1.0, 0.7))
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                      FICHIER: src/geometry.rs                            â•‘
// â•‘  Fonctions de gÃ©omÃ©trie et crÃ©ation de mesh                              â•‘
// â•‘  RÃ´le : GÃ©nÃ©rer les formes gÃ©omÃ©triques et calculer leurs positions     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

//! Module de gÃ©omÃ©trie
//! 
//! Ce module contient toutes les fonctions mathÃ©matiques et de gÃ©nÃ©ration
//! de formes gÃ©omÃ©triques. Il est divisÃ© en plusieurs sections :
//! 
//! 1. Fonctions utilitaires (conversion d'angles)
//! 2. CrÃ©ation de mesh basiques (cercles, triangles)
//! 3. Calculs de positions pour les triangles extÃ©rieurs/intÃ©rieurs
//! 4. DÃ©finition du logo "R" personnalisÃ©

use bevy::prelude::*;
use std::f32::consts::PI;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                        SECTION 1 : FONCTIONS UTILITAIRES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Convertit un angle en degrÃ©s vers des radians
/// 
/// Les fonctions trigonomÃ©triques de Rust (sin, cos, tan) utilisent
/// les radians. Cette fonction permet d'utiliser des degrÃ©s (plus intuitifs).
/// 
/// # Formule
/// radians = degrÃ©s Ã— Ï€ / 180
/// 
/// # Exemples
/// - 0Â° â†’ 0 rad
/// - 90Â° â†’ Ï€/2 rad (â‰ˆ1.57)
/// - 180Â° â†’ Ï€ rad (â‰ˆ3.14)
/// - 360Â° â†’ 2Ï€ rad (â‰ˆ6.28)
pub fn degrees_to_radians(degrees: f32) -> f32 {
    degrees * PI / 180.0
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                      SECTION 2 : CRÃ‰ATION DE MESH BASIQUES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// CrÃ©e un mesh d'anneau (cercle avec un trou au centre)
/// 
/// Un anneau est crÃ©Ã© en gÃ©nÃ©rant deux cercles concentriques
/// (extÃ©rieur et intÃ©rieur) puis en les reliant avec des triangles.
/// 
/// # Algorithme
/// 1. GÃ©nÃ©rer les vertices du cercle extÃ©rieur
/// 2. GÃ©nÃ©rer les vertices du cercle intÃ©rieur
/// 3. CrÃ©er des quadrilatÃ¨res entre les deux cercles
/// 4. Diviser chaque quadrilatÃ¨re en 2 triangles
/// 
/// # Arguments
/// * `outer_radius` - Rayon du cercle extÃ©rieur
/// * `inner_radius` - Rayon du cercle intÃ©rieur
/// * `segments` - Nombre de segments (qualitÃ© du cercle)
/// 
/// # DÃ©tails techniques
/// Pour N segments, on gÃ©nÃ¨re :
/// - 2N vertices (N extÃ©rieurs + N intÃ©rieurs)
/// - 2N triangles (2 triangles par segment)
/// - 6N indices (3 indices par triangle)
pub fn create_circle_mesh(outer_radius: f32, inner_radius: f32, segments: usize) -> Mesh {
    let mut positions = Vec::new();
    let mut indices = Vec::new();

    // === GÃ‰NÃ‰RATION DES VERTICES DU CERCLE EXTÃ‰RIEUR ===
    // On parcourt l'angle de 0 Ã  2Ï€ pour faire le tour complet
    for i in 0..segments {
        // Angle du segment actuel
        let angle = 2.0 * PI * i as f32 / segments as f32;
        
        // Position du vertex sur le cercle extÃ©rieur
        // x = rayon Ã— cos(angle), y = rayon Ã— sin(angle)
        positions.push([
            outer_radius * angle.cos(),
            outer_radius * angle.sin(),
            0.0,  // Z=0 car on travaille en 2D
        ]);
    }

    // === GÃ‰NÃ‰RATION DES VERTICES DU CERCLE INTÃ‰RIEUR ===
    // MÃªme principe mais avec le rayon intÃ©rieur
    for i in 0..segments {
        let angle = 2.0 * PI * i as f32 / segments as f32;
        positions.push([
            inner_radius * angle.cos(),
            inner_radius * angle.sin(),
            0.0,
        ]);
    }

    // === CRÃ‰ATION DES TRIANGLES ===
    // Pour chaque segment, on crÃ©e un quadrilatÃ¨re puis on le divise en 2 triangles
    for i in 0..segments {
        // Index du prochain segment (avec retour au dÃ©but)
        let next = (i + 1) % segments;
        
        // Triangle 1 : coin infÃ©rieur gauche du quadrilatÃ¨re
        // Vertices : extÃ©rieur_i, intÃ©rieur_i, extÃ©rieur_next
        indices.push(i as u32);
        indices.push((segments + i) as u32);
        indices.push(next as u32);
        
        // Triangle 2 : coin supÃ©rieur droit du quadrilatÃ¨re
        // Vertices : extÃ©rieur_next, intÃ©rieur_i, intÃ©rieur_next
        indices.push(next as u32);
        indices.push((segments + i) as u32);
        indices.push((segments + next) as u32);
    }

    // === CRÃ‰ATION DU MESH BEVY ===
    Mesh::new(
        bevy::render::render_resource::PrimitiveTopology::TriangleList,
        bevy::render::render_asset::RenderAssetUsages::RENDER_WORLD,
    )
    .with_inserted_attribute(Mesh::ATTRIBUTE_POSITION, positions)
    .with_inserted_indices(bevy::render::mesh::Indices::U32(indices))
}

/// CrÃ©e un mesh de cercle plein
/// 
/// GÃ©nÃ¨re un cercle solide (disque) en crÃ©ant des triangles
/// depuis le centre vers chaque point du contour.
/// 
/// # Algorithme
/// 1. Placer un vertex au centre (0, 0)
/// 2. GÃ©nÃ©rer N vertices sur le contour
/// 3. CrÃ©er N triangles reliant le centre Ã  chaque paire de vertices adjacents
/// 
/// # Arguments
/// * `radius` - Rayon du cercle
/// * `segments` - Nombre de segments du contour
pub fn create_filled_circle_mesh(radius: f32, segments: usize) -> Mesh {
    let mut positions = Vec::new();
    let mut indices = Vec::new();

    // === VERTEX CENTRAL ===
    // Premier vertex au centre du cercle
    positions.push([0.0, 0.0, 0.0]);

    // === VERTICES DU CONTOUR ===
    // GÃ©nÃ©ration des points sur le pÃ©rimÃ¨tre
    for i in 0..segments {
        let angle = 2.0 * PI * i as f32 / segments as f32;
        positions.push([
            radius * angle.cos(),
            radius * angle.sin(),
            0.0,
        ]);
    }

    // === TRIANGLES EN Ã‰VENTAIL ===
    // Chaque triangle relie le centre Ã  deux vertices adjacents du contour
    for i in 0..segments {
        // Calcul de l'index suivant (retour au dÃ©but pour le dernier)
        let next = if i == segments - 1 { 1 } else { i + 2 };
        
        // Triangle : centre, vertex_i, vertex_suivant
        indices.push(0);              // Centre (index 0)
        indices.push((i + 1) as u32); // Vertex actuel
        indices.push(next as u32);    // Vertex suivant
    }

    Mesh::new(
        bevy::render::render_resource::PrimitiveTopology::TriangleList,
        bevy::render::render_asset::RenderAssetUsages::RENDER_WORLD,
    )
    .with_inserted_attribute(Mesh::ATTRIBUTE_POSITION, positions)
    .with_inserted_indices(bevy::render::mesh::Indices::U32(indices))
}

/// CrÃ©e un triangle Ã  partir de trois points 2D
/// 
/// Fonction simple qui convertit 3 points Vec2 en un mesh triangulaire.
/// 
/// # Arguments
/// * `p1`, `p2`, `p3` - Les trois sommets du triangle
/// 
/// # Note
/// L'ordre des points dÃ©finit l'orientation du triangle (sens horaire/antihoraire)
/// ce qui affecte la face visible (culling).
pub fn create_triangle_from_points(p1: Vec2, p2: Vec2, p3: Vec2) -> Mesh {
    // Conversion des points 2D en positions 3D (Z=0)
    let positions = vec![
        [p1.x, p1.y, 0.0],
        [p2.x, p2.y, 0.0],
        [p3.x, p3.y, 0.0],
    ];

    // Indices des 3 sommets dans l'ordre
    let indices = vec![0u32, 1, 2];

    Mesh::new(
        bevy::render::render_resource::PrimitiveTopology::TriangleList,
        bevy::render::render_asset::RenderAssetUsages::RENDER_WORLD,
    )
    .with_inserted_attribute(Mesh::ATTRIBUTE_POSITION, positions)
    .with_inserted_indices(bevy::render::mesh::Indices::U32(indices))
}

/// CrÃ©e un polygone complexe Ã  partir d'une liste de points
/// 
/// Utilise une triangulation en Ã©ventail (fan triangulation) :
/// - Tous les triangles partagent le premier vertex
/// - Chaque triangle relie le premier vertex Ã  deux vertices consÃ©cutifs
/// 
/// # Limitations
/// Cette mÃ©thode fonctionne bien pour les polygones convexes.
/// Pour les polygones concaves complexes, une triangulation plus
/// sophistiquÃ©e (comme l'algorithme ear-clipping) serait nÃ©cessaire.
/// 
/// # Arguments
/// * `points` - Slice de Vec2 reprÃ©sentant les sommets du polygone
/// 
/// # Panic
/// Panic si moins de 3 points sont fournis
pub fn create_polygon_from_points(points: &[Vec2]) -> Mesh {
    if points.len() < 3 {
        panic!("Un polygone doit avoir au moins 3 points");
    }
    
    // === CONVERSION DES POINTS EN POSITIONS 3D ===
    let positions: Vec<[f32; 3]> = points
        .iter()
        .map(|p| [p.x, p.y, 0.0])
        .collect();
    
    // === TRIANGULATION EN Ã‰VENTAIL ===
    // Pour N points : crÃ©er N-2 triangles
    // Triangle i relie les vertices 0, i, i+1
    let mut indices = Vec::new();
    for i in 1..(points.len() - 1) {
        indices.push(0u32);           // Premier vertex (pivot)
        indices.push(i as u32);       // Vertex actuel
        indices.push((i + 1) as u32); // Vertex suivant
    }
    
    Mesh::new(
        bevy::render::render_resource::PrimitiveTopology::TriangleList,
        bevy::render::render_asset::RenderAssetUsages::RENDER_WORLD,
    )
    .with_inserted_attribute(Mesh::ATTRIBUTE_POSITION, positions)
    .with_inserted_indices(bevy::render::mesh::Indices::U32(indices))
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//            SECTION 3 : CALCULS DE POSITIONS DES TRIANGLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Calcule les coordonnÃ©es d'un triangle extÃ©rieur
/// 
/// Les triangles extÃ©rieurs sont positionnÃ©s de maniÃ¨re Ã  ce qu'un
/// de leurs cÃ´tÃ©s (la base) touche le cercle principal.
/// 
/// # StratÃ©gie de positionnement
/// 1. Calculer deux points sur le cercle (extrÃ©mitÃ©s de la base)
/// 2. Calculer le troisiÃ¨me point Ã  l'extÃ©rieur du cercle
/// 
/// # Arguments
/// * `base_angle` - Angle central du triangle en radians
/// * `circle_radius` - Rayon du cercle de rÃ©fÃ©rence
/// * `triangle_side` - Longueur d'un cÃ´tÃ© du triangle Ã©quilatÃ©ral
/// 
/// # GÃ©omÃ©trie
/// Pour un triangle Ã©quilatÃ©ral de cÃ´tÃ© L :
/// - Hauteur : h = L Ã— âˆš3 / 2
/// - Les deux points de base sont espacÃ©s angulairement de L/R radians
///   oÃ¹ R est le rayon du cercle
pub fn calculate_exterior_triangle_points(
    base_angle: f32,
    circle_radius: f32,
    triangle_side: f32,
) -> (Vec2, Vec2, Vec2) {
    let half_side = triangle_side / 2.0;
    let height = triangle_side * (3.0_f32.sqrt() / 2.0);
    
    // === CALCUL DES DEUX POINTS DE BASE SUR LE CERCLE ===
    // L'Ã©cart angulaire est approximÃ© par half_side / circle_radius
    let angle1 = base_angle - (half_side / circle_radius);
    let angle2 = base_angle + (half_side / circle_radius);
    
    // Point 1 : sur le cercle, Ã  gauche du centre
    let p1 = Vec2::new(
        circle_radius * angle1.cos(),
        circle_radius * angle1.sin(),
    );
    
    // Point 2 : sur le cercle, Ã  droite du centre
    let p2 = Vec2::new(
        circle_radius * angle2.cos(),
        circle_radius * angle2.sin(),
    );
    
    // === CALCUL DU SOMMET EXTÃ‰RIEUR ===
    // PositionnÃ© Ã  une distance de (rayon + hauteur) du centre
    let p3 = Vec2::new(
        (circle_radius + height) * base_angle.cos(),
        (circle_radius + height) * base_angle.sin(),
    );
    
    (p1, p2, p3)
}

/// Calcule les coordonnÃ©es d'un triangle intÃ©rieur
/// 
/// Similaire Ã  calculate_exterior_triangle_points mais :
/// - La base touche le cercle intÃ©rieur
/// - Le sommet pointe vers le centre (intÃ©rieur)
/// 
/// # Arguments
/// * `base_angle` - Angle central du triangle en radians
/// * `inner_radius` - Rayon du cercle intÃ©rieur
/// * `triangle_side` - Longueur d'un cÃ´tÃ© du triangle
pub fn calculate_interior_triangle_points(
    base_angle: f32,
    inner_radius: f32,
    triangle_side: f32,
) -> (Vec2, Vec2, Vec2) {
    let half_side = triangle_side / 2.0;
    let height = triangle_side * (3.0_f32.sqrt() / 2.0);
    
    // === POINTS DE BASE SUR LE CERCLE INTÃ‰RIEUR ===
    let angle1 = base_angle - (half_side / inner_radius);
    let angle2 = base_angle + (half_side / inner_radius);
    
    let p1 = Vec2::new(
        inner_radius * angle1.cos(),
        inner_radius * angle1.sin(),
    );
    let p2 = Vec2::new(
        inner_radius * angle2.cos(),
        inner_radius * angle2.sin(),
    );
    
    // === SOMMET VERS L'INTÃ‰RIEUR ===
    // Distance : rayon - hauteur (pour pointer vers le centre)
    let p3 = Vec2::new(
        (inner_radius - height) * base_angle.cos(),
        (inner_radius - height) * base_angle.sin(),
    );
    
    (p1, p2, p3)
}

/// Calcule le centroÃ¯de (centre de gravitÃ©) d'un triangle
/// 
/// Le centroÃ¯de est le point d'intersection des mÃ©dianes du triangle.
/// Pour un triangle, c'est simplement la moyenne des coordonnÃ©es
/// de ses trois sommets.
/// 
/// # Formule
/// CentroÃ¯de = ((x1+x2+x3)/3, (y1+y2+y3)/3)
/// 
/// # Arguments
/// * `p1`, `p2`, `p3` - Les trois sommets du triangle
/// 
/// # PropriÃ©tÃ©
/// Le centroÃ¯de est Ã©quidistant des trois cÃ´tÃ©s du triangle
pub fn calculate_triangle_centroid(p1: Vec2, p2: Vec2, p3: Vec2) -> Vec2 {
    Vec2::new(
        (p1.x + p2.x + p3.x) / 3.0,
        (p1.y + p2.y + p3.y) / 3.0,
    )
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                    SECTION 4 : DÃ‰FINITION DU LOGO "R"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Structure reprÃ©sentant une partie du logo "R"
/// 
/// Chaque partie du logo est dÃ©finie par :
/// - Un nom descriptif pour l'identification
/// - Une liste de points formant le polygone
/// - Un ordre de profondeur Z pour le rendu en couches
#[derive(Clone)]
pub struct RPartDefinition {
    /// Nom descriptif de la partie (pour debug et logs)
    pub name: &'static str,
    
    /// Liste ordonnÃ©e des sommets du polygone
    /// Les points doivent former un contour dans l'ordre
    pub points: Vec<Vec2>,
    
    /// Ordre de rendu sur l'axe Z (plus Ã©levÃ© = devant)
    /// Recommandation : utiliser des valeurs entre 0.40 et 0.50
    /// pour Ãªtre devant les triangles intÃ©rieurs (Z=0.3)
    pub z_order: f32,
}

/// Retourne toutes les parties composant le logo "R"
/// 
/// Le logo "R" est dÃ©composÃ© en 8 parties gÃ©omÃ©triques distinctes :
/// 1. Haut : barre horizontale supÃ©rieure
/// 2. Gauche : barre verticale principale
/// 3. Arrondi : courbe de la partie droite supÃ©rieure
/// 4. Centre : petite barre de sÃ©paration
/// 5. Pied gauche : base Ã©largie Ã  gauche
/// 6. Milieu : zone de connexion centrale
/// 7. Jambe droite : diagonale partant vers la droite
/// 8. Pied droit : base Ã©largie Ã  droite
/// 
/// # Organisation
/// Chaque partie a un z_order incrÃ©mental (0.40 Ã  0.47) pour
/// s'assurer qu'elles se superposent correctement sans conflit visuel.
/// 
/// # CoordonnÃ©es
/// Les coordonnÃ©es sont dÃ©finies dans un systÃ¨me oÃ¹ :
/// - (0, 0) est au centre de l'Ã©cran
/// - X positif va vers la droite
/// - Y positif va vers le haut
/// 
/// # Modification
/// Pour ajuster le logo :
/// 1. Modifier les Vec2::new(x, y) de chaque partie
/// 2. Pour ajouter une partie : ajouter un nouveau RPartDefinition
/// 3. Pour supprimer une partie : commenter ou retirer le bloc
pub fn get_all_r_parts() -> Vec<RPartDefinition> {
    vec![
        // === PARTIE 1 : BARRE HORIZONTALE SUPÃ‰RIEURE ===
        RPartDefinition {
            name: "Haut du R",
            z_order: 0.40,
            points: vec![
                Vec2::new(-140.0, 90.0),  // Coin supÃ©rieur gauche
                Vec2::new(60.0, 90.0),    // Coin supÃ©rieur droit
                Vec2::new(60.0, 50.0),    // Coin infÃ©rieur droit
                Vec2::new(-100.0, 50.0),  // Coin infÃ©rieur gauche
            ],
        },
        
        // === PARTIE 2 : BARRE VERTICALE PRINCIPALE GAUCHE ===
        RPartDefinition {
            name: "Gauche du R",
            z_order: 0.41,
            points: vec![
                Vec2::new(-80.0, 50.0),   // Haut de la barre
                Vec2::new(-30.0, 50.0),   // Haut droit
                Vec2::new(-30.0, -50.0),  // Bas droit
                Vec2::new(-80.0, -50.0),  // Bas gauche
            ],
        },
        
        // === PARTIE 3 : COURBE ARRONDIE DROITE ===
        // Points formant l'arrondi caractÃ©ristique du "R"
        RPartDefinition {
            name: "Arrondi du R",
            z_order: 0.42,
            points: vec![
                Vec2::new(60.0, 90.0),    // DÃ©part en haut
                Vec2::new(85.0, 60.0),    // Premier point de courbe
                Vec2::new(100.0, 30.0),   // Point le plus Ã  droite
                Vec2::new(85.0, 0.0),     // Descente de la courbe
                Vec2::new(60.0, -30.0),   // Fin de l'arrondi
            ],
        },
        
        // === PARTIE 4 : SÃ‰PARATEUR CENTRAL ===
        // Petite barre horizontale au milieu
        RPartDefinition {
            name: "Centre du R",
            z_order: 0.43,
            points: vec![
                Vec2::new(60.0, 50.0),    // Haut gauche
                Vec2::new(40.0, 50.0),    // Haut droit
                Vec2::new(60.0, 10.0),    // Bas gauche
                Vec2::new(40.0, 10.0),    // Bas droit
            ],
        },
        
        // === PARTIE 5 : PIED GAUCHE Ã‰LARGI ===
        RPartDefinition {
            name: "Pied gauche du R",
            z_order: 0.44,
            points: vec![
                Vec2::new(-80.0, -50.0),   // Connexion avec barre verticale
                Vec2::new(-10.0, -50.0),   // Vers le centre
                Vec2::new(-10.0, -80.0),   // Descente
                Vec2::new(-140.0, -80.0),  // Largeur maximale du pied
                Vec2::new(-160.0, -50.0),  // Retour vers le haut
                Vec2::new(-80.0, -50.0),   // Fermeture
            ],
        },
        
        // === PARTIE 6 : ZONE DE CONNEXION CENTRALE ===
        RPartDefinition {
            name: "Milieu du R",
            z_order: 0.45,
            points: vec![
                Vec2::new(60.0, -30.0),   // Connexion avec arrondi
                Vec2::new(60.0, 10.0),    // MontÃ©e
                Vec2::new(-30.0, 10.0),   // Vers la gauche
                Vec2::new(-30.0, -30.0),  // Redescente
            ],
        },
        
        // === PARTIE 7 : JAMBE DIAGONALE DROITE ===
        RPartDefinition {
            name: "Jambe droite du R",
            z_order: 0.46,
            points: vec![
                Vec2::new(60.0, -30.0),   // DÃ©part sous l'arrondi
                Vec2::new(20.0, -30.0),   // Vers l'intÃ©rieur
                Vec2::new(60.0, -50.0),   // Diagonale vers le bas-droit
                Vec2::new(100.0, -50.0),  // Extension droite
            ],
        },
        
        // === PARTIE 8 : PIED DROIT Ã‰LARGI ===
        RPartDefinition {
            name: "Pied droit du R",
            z_order: 0.47,
            points: vec![
                Vec2::new(160.0, -50.0),  // ExtrÃ©mitÃ© droite
                Vec2::new(30.0, -50.0),   // Vers le centre
                Vec2::new(30.0, -80.0),   // Descente
                Vec2::new(120.0, -80.0),  // Largeur du pied
            ],
        },
    ]
}

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                    FICHIER: src/systems/mod.rs                           â•‘
// â•‘  DÃ©claration des sous-modules du dossier systems                         â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

//! Module systems
//! 
//! Contient tous les systÃ¨mes Bevy de l'application.
//! Actuellement : un seul systÃ¨me de setup pour l'initialisation.

/// Module de configuration initiale
/// Contient le systÃ¨me qui crÃ©e tous les Ã©lÃ©ments visuels au dÃ©marrage
pub mod setup;

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                   FICHIER: src/systems/setup.rs                          â•‘
// â•‘  SystÃ¨me d'initialisation de la scÃ¨ne                                    â•‘
// â•‘  RÃ´le : CrÃ©er tous les Ã©lÃ©ments visuels au dÃ©marrage                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

//! Module setup
//! 
//! Ce module contient toute la logique d'initialisation de l'application.
//! Il est responsable de la crÃ©ation de :
//! - La camÃ©ra 2D
//! - Le cercle principal (anneau)
//! - Les triangles extÃ©rieurs (arc-en-ciel)
//! - Les triangles intÃ©rieurs (pentagone)
//! - Les petits cercles centraux
//! - Le logo "R" personnalisÃ©
//! 
//! Organisation du rendu par profondeur Z :
//! - Z = 0.0  : Cercle principal (arriÃ¨re-plan)
//! - Z = 0.1  : Triangles extÃ©rieurs
//! - Z = 0.2  : Triangles intÃ©rieurs
//! - Z = 0.3  : Petits cercles
//! - Z = 0.4+ : Logo "R" (8 parties de 0.40 Ã  0.47)

use bevy::prelude::*;
use crate::{config, materials, geometry};

/// SystÃ¨me principal d'initialisation
/// 
/// Ce systÃ¨me est exÃ©cutÃ© une seule fois au dÃ©marrage (Startup schedule).
/// Il reÃ§oit trois ressources mutables de Bevy :
/// 
/// # Arguments
/// * `commands` - File de commandes pour crÃ©er/supprimer des entitÃ©s
/// * `meshes` - Collection Asset des meshes 3D/2D
/// * `materials` - Collection Asset des matÃ©riaux (couleurs, textures)
/// 
/// # Ordre d'exÃ©cution
/// 1. CrÃ©ation de la camÃ©ra (sans elle, rien n'est visible)
/// 2. CrÃ©ation des Ã©lÃ©ments de fond vers l'avant (ordre Z croissant)
/// 3. Affichage du rÃ©sumÃ© dans la console
/// 
/// # Note technique
/// Les systÃ¨mes Bevy sont des fonctions qui reÃ§oivent des paramÃ¨tres
/// spÃ©ciaux (Commands, Query, Res, ResMut, etc.) injectÃ©s automatiquement
/// par l'ECS (Entity Component System) de Bevy.
pub fn setup_system(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
) {
    // === CAMÃ‰RA 2D ===
    // Obligatoire : sans camÃ©ra, aucun Ã©lÃ©ment n'est rendu
    // Camera2d::default() crÃ©e une camÃ©ra orthographique 2D centrÃ©e
    commands.spawn(Camera2d::default());
    
    // === CRÃ‰ATION DES Ã‰LÃ‰MENTS VISUELS ===
    // Ordre logique : du fond vers l'avant (mais le Z dÃ©termine l'ordre rÃ©el)
    
    create_main_circle(&mut commands, &mut meshes, &mut materials);
    create_exterior_triangles(&mut commands, &mut meshes, &mut materials);
    create_interior_triangles(&mut commands, &mut meshes, &mut materials);
    create_r_logo(&mut commands, &mut meshes, &mut materials);
    
    // === RÃ‰SUMÃ‰ CONSOLE ===
    print_creation_summary();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                  FONCTIONS DE CRÃ‰ATION DES Ã‰LÃ‰MENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// CrÃ©e le cercle principal (anneau Ã©pais)
/// 
/// Le cercle principal est l'Ã©lÃ©ment de fond du logo.
/// Il est crÃ©Ã© comme un anneau (donut) avec un trou au centre.
/// 
/// # ParamÃ¨tres utilisÃ©s
/// - CIRCLE_RADIUS : rayon extÃ©rieur
/// - CIRCLE_THICKNESS : Ã©paisseur de l'anneau
/// - CIRCLE_SEGMENTS : qualitÃ© du rendu
/// 
/// # Position
/// - X, Y : (0, 0) - centre de l'Ã©cran
/// - Z : 0.0 - complÃ¨tement en arriÃ¨re-plan
fn create_main_circle(
    commands: &mut Commands,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<ColorMaterial>>,
) {
    // === CALCUL DES DIMENSIONS ===
    let outer_radius = config::CIRCLE_RADIUS;
    let inner_radius = config::CIRCLE_RADIUS - config::CIRCLE_THICKNESS;
    
    // === CRÃ‰ATION DU MESH ===
    let circle_mesh = geometry::create_circle_mesh(
        outer_radius,
        inner_radius,
        config::CIRCLE_SEGMENTS
    );
    
    // === AJOUT AUX ASSETS ===
    // add() retourne un Handle<Mesh> qui rÃ©fÃ©rence le mesh
    let circle_handle = meshes.add(circle_mesh);
    
    // === MATÃ‰RIAU (COULEUR) ===
    let circle_material = materials.add(materials::get_main_circle_color());
    
    // === CRÃ‰ATION DE L'ENTITÃ‰ ===
    // Une entitÃ© est crÃ©Ã©e avec 3 composants :
    // - Mesh2d : quel mesh afficher
    // - MeshMaterial2d : quelle apparence appliquer
    // - Transform : position, rotation, Ã©chelle
    commands.spawn((
        Mesh2d(circle_handle),
        MeshMaterial2d(circle_material),
        Transform::from_xyz(0.0, 0.0, 0.0),
    ));
}

/// CrÃ©e les triangles extÃ©rieurs en arc-en-ciel
/// 
/// GÃ©nÃ¨re 36 petits triangles disposÃ©s en cercle autour du cercle principal.
/// Chaque triangle a une couleur diffÃ©rente crÃ©ant un gradient arc-en-ciel.
/// 
/// # CaractÃ©ristiques
/// - Nombre : EXTERIOR_TRIANGLES_COUNT (36)
/// - Espacement : 10Â° entre chaque (360Â° / 36)
/// - Couleur : progression HSL de 0Â° Ã  360Â°
/// - Position : base du triangle sur le cercle
/// - Z : 0.1 (devant le cercle principal)
/// 
/// # Algorithme
/// Pour chaque position angulaire :
/// 1. Calculer l'angle (i Ã— 10Â°)
/// 2. Calculer les 3 points du triangle
/// 3. CrÃ©er le mesh triangulaire
/// 4. Attribuer la couleur arc-en-ciel
/// 5. Spawner l'entitÃ©
fn create_exterior_triangles(
    commands: &mut Commands,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<ColorMaterial>>,
) {
    // === BOUCLE SUR TOUS LES TRIANGLES ===
    for i in 0..config::EXTERIOR_TRIANGLES_COUNT {
        // === CALCUL DE L'ANGLE ===
        // Espacement rÃ©gulier : 360Â° / nombre de triangles
        let angle_degrees = (i as f32) * 10.0;
        let base_angle = geometry::degrees_to_radians(angle_degrees);
        
        // === CALCUL DES POINTS ===
        let (p1, p2, p3) = geometry::calculate_exterior_triangle_points(
            base_angle,
            config::CIRCLE_RADIUS,
            config::SMALL_TRIANGLE_SIDE
        );
        
        // === CRÃ‰ATION DU MESH ===
        let triangle_mesh = geometry::create_triangle_from_points(p1, p2, p3);
        let triangle_handle = meshes.add(triangle_mesh);
        
        // === COULEUR ARC-EN-CIEL ===
        // Chaque triangle a une teinte diffÃ©rente
        let color = materials::get_rainbow_color(i);
        let triangle_material = materials.add(color);
        
        // === SPAWN ===
        commands.spawn((
            Mesh2d(triangle_handle),
            MeshMaterial2d(triangle_material),
            Transform::from_xyz(0.0, 0.0, 0.1),
        ));
    }
}

/// CrÃ©e les triangles intÃ©rieurs avec petits cercles
/// 
/// GÃ©nÃ¨re 5 grands triangles formant un pentagone rÃ©gulier Ã  l'intÃ©rieur
/// du cercle. Chaque triangle a un petit cercle blanc semi-transparent
/// positionnÃ© Ã  son centre (centroÃ¯de).
/// 
/// # CaractÃ©ristiques
/// - Nombre : INTERIOR_TRIANGLES_COUNT (5)
/// - Disposition : pentagone rÃ©gulier (72Â° entre triangles)
/// - Orientation : un triangle pointe vers le haut (+90Â° offset)
/// - Couleurs : palette de 5 couleurs distinctes
/// - Cercles centraux : blancs semi-transparents (alpha 0.7)
/// 
/// # Ordre de crÃ©ation par triangle
/// 1. Calculer l'angle de position
/// 2. Calculer les 3 sommets du triangle
/// 3. CrÃ©er et spawner le triangle (Z=0.2)
/// 4. Calculer le centroÃ¯de
/// 5. CrÃ©er et spawner le petit cercle (Z=0.3)
fn create_interior_triangles(
    commands: &mut Commands,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<ColorMaterial>>,
) {
    // === BOUCLE SUR LES 5 TRIANGLES ===
    for i in 0..config::INTERIOR_TRIANGLES_COUNT {
        // === ANGLE DE POSITION ===
        // 72Â° d'espacement (360Â° / 5) + 90Â° pour orientation vers le haut
        let angle_degrees = (i as f32) * 72.0 + 90.0;
        let base_angle = geometry::degrees_to_radians(angle_degrees);
        
        // === RAYON INTÃ‰RIEUR DISPONIBLE ===
        let inner_radius = config::CIRCLE_RADIUS - config::CIRCLE_THICKNESS;
        
        // === CALCUL DES POINTS DU TRIANGLE ===
        let (p1, p2, p3) = geometry::calculate_interior_triangle_points(
            base_angle,
            inner_radius,
            config::LARGE_TRIANGLE_SIDE
        );
        
        // === CALCUL DU CENTROÃDE ===
        // Le centroÃ¯de servira de position pour le petit cercle
        let triangle_center = geometry::calculate_triangle_centroid(p1, p2, p3);
        
        // === CRÃ‰ATION DU TRIANGLE ===
        let triangle_mesh = geometry::create_triangle_from_points(p1, p2, p3);
        let triangle_handle = meshes.add(triangle_mesh);
        
        // Couleur spÃ©cifique Ã  ce triangle
        let triangle_color = materials::get_interior_triangle_color(i);
        let triangle_material = materials.add(triangle_color);
        
        // Spawn du triangle Ã  Z=0.2
        commands.spawn((
            Mesh2d(triangle_handle),
            MeshMaterial2d(triangle_material),
            Transform::from_xyz(0.0, 0.0, 0.2),
        ));
        
        // === CRÃ‰ATION DU PETIT CERCLE CENTRAL ===
        let small_circle_mesh = geometry::create_filled_circle_mesh(
            config::SMALL_CIRCLE_RADIUS,
            config::SMALL_CIRCLE_SEGMENTS
        );
        let small_circle_handle = meshes.add(small_circle_mesh);
        
        // MatÃ©riau blanc semi-transparent
        let small_circle_material = materials.add(materials::get_small_circle_color());
        
        // Spawn du cercle au centroÃ¯de Ã  Z=0.3
        commands.spawn((
            Mesh2d(small_circle_handle),
            MeshMaterial2d(small_circle_material),
            Transform::from_xyz(triangle_center.x, triangle_center.y, 0.3),
        ));
    }
}

/// CrÃ©e le logo "R" complet
/// 
/// Cette fonction gÃ©nÃ¨re toutes les parties du logo "R" de maniÃ¨re unifiÃ©e.
/// Le logo est composÃ© de 8 polygones distincts qui forment ensemble
/// la lettre "R" stylisÃ©e.
/// 
/// # Avantages de cette approche
/// - Code unifiÃ© : une seule boucle pour toutes les parties
/// - Maintenance facile : ajout/suppression de parties simple
/// - CohÃ©rence : mÃªme couleur et mÃªme logique pour toutes les parties
/// - Debug efficace : messages descriptifs pour chaque partie
/// 
/// # Configuration
/// - Couleur : orange vif (modifiable en une ligne)
/// - Z-order : 0.40 Ã  0.47 (dÃ©fini dans chaque RPartDefinition)
/// - GÃ©omÃ©trie : dÃ©finie dans geometry::get_all_r_parts()
/// 
/// # Process par partie
/// 1. Validation (minimum 3 points)
/// 2. CrÃ©ation du mesh polygonal
/// 3. Application du matÃ©riau colorÃ©
/// 4. Spawn Ã  la position centrale avec Z-order appropriÃ©
/// 5. Log de confirmation
fn create_r_logo(
    commands: &mut Commands,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<ColorMaterial>>,
) {
    // === COULEUR UNIQUE POUR TOUT LE LOGO ===
    // Modifier cette ligne pour changer la couleur de tout le "R"
    // Exemples :
    // - Rouge : Color::srgba(1.0, 0.0, 0.0, 0.8)
    // - Bleu : Color::srgba(0.2, 0.6, 1.0, 0.8)
    // - Vert : Color::srgba(0.2, 0.8, 0.3, 0.8)
    let r_color = Color::srgba(1.0, 0.5, 0.0, 0.8); // Orange
    
    // === PARCOURS DE TOUTES LES PARTIES ===
    for part in geometry::get_all_r_parts() {
        // === VALIDATION ===
        // Un polygone nÃ©cessite au moins 3 points
        if part.points.len() < 3 {
            println!("âš ï¸ '{}' ignorÃ© : moins de 3 points", part.name);
            continue;
        }
        
        // === CRÃ‰ATION DU MESH POLYGONAL ===
        let mesh = geometry::create_polygon_from_points(&part.points);
        let mesh_handle = meshes.add(mesh);
        
        // === MATÃ‰RIAU ===
        let material = materials.add(ColorMaterial::from(r_color));
        
        // === SPAWN DE LA PARTIE ===
        // Position : centre (0, 0)
        // Z : dÃ©fini dans part.z_order pour chaque partie
        commands.spawn((
            Mesh2d(mesh_handle),
            MeshMaterial2d(material),
            Transform::from_xyz(0.0, 0.0, part.z_order),
        ));
        
        // === LOG DE CONFIRMATION ===
        println!("   âœ¨ '{}' crÃ©Ã© avec {} points (Z={})", 
                 part.name, part.points.len(), part.z_order);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                        FONCTION DE RÃ‰SUMÃ‰
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// Affiche un rÃ©sumÃ© dÃ©taillÃ© de la crÃ©ation
/// 
/// Cette fonction est appelÃ©e Ã  la fin du setup pour confirmer
/// que tous les Ã©lÃ©ments ont Ã©tÃ© crÃ©Ã©s correctement.
/// Elle affiche dans la console :
/// - Le nombre d'Ã©lÃ©ments de chaque type
/// - Les paramÃ¨tres de configuration utilisÃ©s
/// - L'organisation des couches Z
/// 
/// Utile pour :
/// - VÃ©rifier que l'initialisation s'est bien passÃ©e
/// - DÃ©bugger en cas de problÃ¨me visuel
/// - Documenter la structure du rendu
fn print_creation_summary() {
    // Comptage dynamique des parties du logo R
    let r_parts_count = geometry::get_all_r_parts().len();
    
    println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘           CRÃ‰ATION TERMINÃ‰E - RÃ‰SUMÃ‰                     â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    
    println!("\nğŸ“Š Ã‰LÃ‰MENTS CRÃ‰Ã‰S :");
    println!("   âœ“ 1 cercle principal (anneau Ã©pais)");
    println!("   âœ“ {} triangles extÃ©rieurs arc-en-ciel", config::EXTERIOR_TRIANGLES_COUNT);
    println!("   âœ“ {} triangles intÃ©rieurs colorÃ©s", config::INTERIOR_TRIANGLES_COUNT);
    println!("   âœ“ {} petits cercles centraux", config::INTERIOR_TRIANGLES_COUNT);
    println!("   âœ“ {} parties du logo 'R'", r_parts_count);
    
    println!("\nğŸ”§ PARAMÃˆTRES DE CONFIGURATION :");
    println!("   â€¢ Rayon principal : {} px", config::CIRCLE_RADIUS);
    println!("   â€¢ Ã‰paisseur anneau : {} px", config::CIRCLE_THICKNESS);
    println!("   â€¢ Rayon intÃ©rieur : {} px", config::CIRCLE_RADIUS - config::CIRCLE_THICKNESS);
    println!("   â€¢ QualitÃ© cercles : {} segments", config::CIRCLE_SEGMENTS);
    println!("   â€¢ Taille triangles extÃ©rieurs : {} px", config::SMALL_TRIANGLE_SIDE);
    println!("   â€¢ Taille triangles intÃ©rieurs : {} px", config::LARGE_TRIANGLE_SIDE);
    
    println!("\nğŸ¬ ORGANISATION DES COUCHES (Z) :");
    println!("   â€¢ Z = 0.0  : Cercle principal (arriÃ¨re-plan)");
    println!("   â€¢ Z = 0.1  : Triangles extÃ©rieurs arc-en-ciel");
    println!("   â€¢ Z = 0.2  : Triangles intÃ©rieurs colorÃ©s");
    println!("   â€¢ Z = 0.3  : Petits cercles blancs");
    println!("   â€¢ Z = 0.4+ : Logo 'R' ({} parties)", r_parts_count);
    
    println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘  ğŸš€ Application Bevy prÃªte - FenÃªtre ouverte             â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}